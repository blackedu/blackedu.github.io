# 图文讲解冒泡排序
![气泡图片](media/15958194010780/%E6%B0%94%E6%B3%A1%E5%9B%BE%E7%89%87.jpg)

**冒泡排序算法**是一种非常基础的排序算法，算法的原理相对简单，同时也是稳定的排序算法，算法的时间复杂度为$o(n^2)$，另外还是一种原地排序。比较适用于小规模数据的排序。

解释一下概念：
1. 排序算法的`稳定性`是指**两个相等的元素排序以后相对位置不发生变化，则认为是稳定的排序**
2. 算法的`时间复杂度`是**指随着问题规模的增加，理论执行时间的变化趋势**。比如$o(n)$是指随之问题规模的增加，理论执行时间是线性递增的。放在排序问题中就是随着数据个数增加，排序所需的时间是呈线性增加的。而$o(n^2)$，就是数据个数增加，理论所需时间是平方级别的增加。处理同一问题，$o(n)$肯定比$o(n^2)$要好得多。

冒泡排序的算法原理一句话就能说清楚

> 遍历比较相邻的元素，交换符合条件的两个元素

## 看例子
接下来看一个简单的排序例子。按照从小到大的顺序对下列数字进行排序：

```
4, 9, 6, 11, 1, 5
```

遍历比较相邻两个数字，前者大则交换两个元素的位置，第1轮下来最大的元素“沉到”最后；重复上面的操作，第2轮遍历第二大元素“沉到”最大气泡的前面；依次重复到第5轮以后，就能得到最终的有序序列。

![冒泡排序](media/15958194010780/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif)

## 参考代码
写代码有个地方需要注意，第1轮循环终止位置是序列长度减1，也就是轮数增大，循环的终止位置在逐渐减小， 两者之和等于序列的长度。

```python
from typing import List

def bubble(data: List[int])-> List[int]:
    for i in range(len(data)-1, 0, -1): # 注意倒序输出
        for j in range(0, i): # 下标变化
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j] # 相邻元素比较
    return data

l = [4, 9, 6, 11, 1, 5]
print(bubble(l))

# [1, 4, 5, 6, 9, 11]
```

## 总结
冒泡排序是排序算法中相对简单的算法，原理非常容易理解，代码的实现过程有个细节需要注意，代码中已经注释出来。另外冒泡排序还是一种原地排序，在整个排序过程中不需要多余的空间，来存储中间结果。今天你是否又学会了一种排序算法呢？


